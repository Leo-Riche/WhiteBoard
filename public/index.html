<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dessiner & Deviner</title>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      .canvas-container {
        max-width: 100%;
        overflow-x: auto;
      }

      #canvas {
        min-width: 320px;
        max-width: 100%;
      }

      @media (max-width: 768px) {
        #canvas {
          width: 100% !important;
          height: auto !important;
          max-width: calc(100vw - 2rem);
          aspect-ratio: 8/5;
        }
      }

      .touch-none {
        touch-action: none;
      }
    </style>
  </head>
  <body class="bg-gray-100 min-h-screen p-2 md:p-4">
    <h1 class="text-2xl md:text-3xl font-bold text-center mb-4 md:mb-6">
      ğŸ¨ Dessiner & Deviner
    </h1>

    <div
      id="joinModal"
      class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
    >
      <div class="bg-white p-6 md:p-8 rounded-lg shadow-lg max-w-md w-full">
        <h2 class="text-xl md:text-2xl font-bold mb-4 text-center">
          Rejoindre le jeu
        </h2>
        <input
          type="text"
          id="playerNameInput"
          placeholder="Votre nom"
          class="w-full p-3 border rounded mb-4 text-base md:text-lg"
        />
        <button
          id="joinGameBtn"
          class="w-full bg-blue-500 text-white p-3 rounded text-base md:text-lg hover:bg-blue-600"
        >
          ğŸ® Rejoindre
        </button>
      </div>
    </div>

    <div id="gameInterface" class="hidden">
      <div class="flex flex-col lg:flex-row gap-4 lg:gap-6 max-w-7xl mx-auto">
        <div class="w-full lg:w-80 space-y-4 order-2 lg:order-1">
          <div class="bg-white p-3 md:p-4 rounded-lg shadow">
            <h3 class="font-bold text-base md:text-lg mb-2">ğŸ“Š Ã‰tat du jeu</h3>
            <div id="gameStatus" class="text-gray-600 text-sm md:text-base">
              En attente de joueurs... (Il faut au moins 2 joueurs)
            </div>
            <div
              id="currentDrawer"
              class="text-blue-600 font-medium mt-2 text-sm md:text-base"
            ></div>
            <div
              id="wordToGuess"
              class="text-green-600 font-bold text-lg md:text-xl mt-2"
            ></div>
            <div
              id="timer"
              class="text-red-500 font-mono text-base md:text-lg mt-2"
            ></div>

            <button
              id="startGameBtn"
              class="hidden w-full mt-3 bg-blue-500 text-white p-2 md:p-3 rounded text-sm md:text-lg hover:bg-blue-600 font-bold"
            >
              ğŸ® DÃ©marrer le jeu
            </button>

            <button
              id="nextRoundBtn"
              class="hidden w-full mt-3 bg-green-500 text-white p-2 md:p-3 rounded text-sm md:text-lg hover:bg-green-600 font-bold"
            >
              ğŸš€ Lancer la prochaine manche
            </button>
          </div>

          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-1 gap-4">
            <div class="bg-white p-3 md:p-4 rounded-lg shadow">
              <h3 class="font-bold text-base md:text-lg mb-2">ï¿½ Joueurs</h3>
              <div id="playersList" class="space-y-2"></div>
            </div>

            <div class="bg-white p-3 md:p-4 rounded-lg shadow">
              <h3 class="font-bold text-base md:text-lg mb-2">ğŸ’¬ Chat</h3>

              <div
                id="almostMessage"
                class="hidden mb-2 p-2 bg-orange-100 border-l-4 border-orange-500 rounded text-sm font-medium text-orange-700"
              ></div>

              <div
                id="chatMessages"
                class="h-32 md:h-40 overflow-y-auto border p-2 mb-2 bg-gray-50 rounded text-sm"
              ></div>
              <div class="flex gap-2">
                <input
                  type="text"
                  id="chatInput"
                  placeholder="Devinez le mot..."
                  class="flex-1 p-2 border rounded text-sm md:text-base"
                  disabled
                />
                <button
                  id="sendChatBtn"
                  class="bg-green-500 text-white px-3 md:px-4 py-2 rounded hover:bg-green-600 text-sm md:text-base"
                  disabled
                >
                  Envoyer
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="flex-1 order-1 lg:order-2">
          <div class="bg-white p-3 md:p-4 rounded-lg shadow mb-4">
            <div
              class="grid grid-cols-3 md:flex md:flex-wrap gap-2 items-center"
            >
              <input
                type="color"
                id="colorPicker"
                class="w-10 h-10 md:w-12 md:h-12 p-0 border-none cursor-pointer rounded"
                disabled
              />
              <button
                id="pencilBtn"
                class="bg-blue-500 text-white p-2 rounded hover:bg-blue-600 text-xs md:text-sm flex items-center justify-center"
                disabled
              >
                <span class="md:hidden">âœï¸</span>
                <span class="hidden md:inline">âœï¸ Crayon</span>
              </button>
              <button
                id="eraserBtn"
                class="bg-gray-500 text-white p-2 rounded hover:bg-gray-600 text-xs md:text-sm flex items-center justify-center"
                disabled
              >
                <span class="md:hidden">ğŸ§½</span>
                <span class="hidden md:inline">ğŸ§½ Gomme</span>
              </button>
              <button
                id="lineBtn"
                class="bg-green-500 text-white p-2 rounded hover:bg-green-600 text-xs md:text-sm flex items-center justify-center"
                disabled
              >
                <span class="md:hidden">ğŸ“</span>
                <span class="hidden md:inline">ğŸ“ Ligne</span>
              </button>
              <select
                id="lineWidth"
                class="p-2 border rounded text-xs md:text-sm"
                disabled
              >
                <option value="2">Fin</option>
                <option value="5" selected>Moyen</option>
                <option value="10">Ã‰pais</option>
              </select>
              <button
                id="clearBtn"
                class="bg-red-500 text-white p-2 rounded hover:bg-red-600 text-xs md:text-sm flex items-center justify-center"
                disabled
              >
                <span class="md:hidden">ğŸ—‘ï¸</span>
                <span class="hidden md:inline">ğŸ—‘ï¸ Nettoyer</span>
              </button>
            </div>
          </div>

          <!-- Canvas Container -->
          <div class="bg-white p-2 md:p-4 rounded-lg shadow">
            <div class="canvas-container overflow-auto">
              <canvas
                id="canvas"
                class="border rounded bg-white shadow-lg mx-auto block touch-none"
                width="800"
                height="500"
              ></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const socket = io();
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      let drawing = false;
      let currentTool = "pencil";
      let startX, startY;
      let isDrawer = false;
      let gameTimer = null;

      function resizeCanvas() {
        const container = document.querySelector(".canvas-container");
        const containerWidth = container.clientWidth;
        const isMobile = window.innerWidth < 768;

        if (isMobile) {
          const maxWidth = Math.min(
            containerWidth - 16,
            window.innerWidth - 32
          );
          const newHeight = (maxWidth * 5) / 8; 

          canvas.style.width = maxWidth + "px";
          canvas.style.height = newHeight + "px";
        } else {
          canvas.style.width = "800px";
          canvas.style.height = "500px";
        }
      }

      function getEventPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        let clientX, clientY;

        if (e.touches && e.touches.length > 0) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }

        return {
          x: (clientX - rect.left) * scaleX,
          y: (clientY - rect.top) * scaleY,
        };
      }

      // Ã‰lÃ©ments DOM
      const joinModal = document.getElementById("joinModal");
      const gameInterface = document.getElementById("gameInterface");
      const playerNameInput = document.getElementById("playerNameInput");
      const joinGameBtn = document.getElementById("joinGameBtn");
      const gameStatus = document.getElementById("gameStatus");
      const currentDrawer = document.getElementById("currentDrawer");
      const wordToGuess = document.getElementById("wordToGuess");
      const timer = document.getElementById("timer");
      const playersList = document.getElementById("playersList");
      const chatMessages = document.getElementById("chatMessages");
      const almostMessage = document.getElementById("almostMessage");
      const chatInput = document.getElementById("chatInput");
      const sendChatBtn = document.getElementById("sendChatBtn");
      const startGameBtn = document.getElementById("startGameBtn");
      const nextRoundBtn = document.getElementById("nextRoundBtn");
      const colorPicker = document.getElementById("colorPicker");
      const lineWidth = document.getElementById("lineWidth");
      const clearBtn = document.getElementById("clearBtn");
      const pencilBtn = document.getElementById("pencilBtn");
      const eraserBtn = document.getElementById("eraserBtn");
      const lineBtn = document.getElementById("lineBtn");

      joinGameBtn.addEventListener("click", () => {
        const name = playerNameInput.value.trim();
        if (name) {
          socket.emit("joinGame", name);
          joinModal.classList.add("hidden");
          gameInterface.classList.remove("hidden");
        }
      });

      playerNameInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          joinGameBtn.click();
        }
      });

      sendChatBtn.addEventListener("click", sendMessage);
      chatInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          sendMessage();
        }
      });

      startGameBtn.addEventListener("click", () => {
        socket.emit("startGame");
        startGameBtn.disabled = true;
        startGameBtn.textContent = "â³ DÃ©marrage en cours...";
      });

      nextRoundBtn.addEventListener("click", () => {
        socket.emit("startNextRound");
        nextRoundBtn.disabled = true;
        nextRoundBtn.textContent = "â³ Lancement en cours...";
      });

      function sendMessage() {
        const message = chatInput.value.trim();
        if (message) {
          socket.emit("chatMessage", message);
          chatInput.value = "";
        }
      }

      pencilBtn.addEventListener("click", () => {
        currentTool = "pencil";
        updateToolButtons();
      });
      eraserBtn.addEventListener("click", () => {
        currentTool = "eraser";
        updateToolButtons();
      });
      lineBtn.addEventListener("click", () => {
        currentTool = "line";
        updateToolButtons();
      });

      function updateToolButtons() {
        [pencilBtn, eraserBtn, lineBtn].forEach((btn) =>
          btn.classList.remove("ring-2", "ring-yellow-400")
        );
        if (currentTool === "pencil")
          pencilBtn.classList.add("ring-2", "ring-yellow-400");
        if (currentTool === "eraser")
          eraserBtn.classList.add("ring-2", "ring-yellow-400");
        if (currentTool === "line")
          lineBtn.classList.add("ring-2", "ring-yellow-400");
      }

      function startDrawing(e) {
        if (!isDrawer) return;
        e.preventDefault();

        drawing = true;
        ctx.beginPath();
        const pos = getEventPos(e);
        startX = pos.x;
        startY = pos.y;

        if (currentTool === "line") return;

        ctx.moveTo(pos.x, pos.y);
        socket.emit("draw", {
          x: pos.x,
          y: pos.y,
          color: currentTool === "eraser" ? "#FFFFFF" : colorPicker.value,
          width: currentTool === "eraser" ? 20 : lineWidth.value,
          start: true,
        });
      }

      function continueDrawing(e) {
        if (!drawing || !isDrawer) return;
        e.preventDefault();

        if (currentTool === "line") return;

        const color = currentTool === "eraser" ? "#FFFFFF" : colorPicker.value;
        const width = currentTool === "eraser" ? 20 : lineWidth.value;
        const pos = getEventPos(e);

        ctx.lineTo(pos.x, pos.y);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.lineCap = "round";
        ctx.stroke();

        socket.emit("draw", {
          x: pos.x,
          y: pos.y,
          color,
          width,
          start: false,
        });
      }

      function stopDrawing(e) {
        if (!isDrawer) return;
        e.preventDefault();

        if (currentTool === "line" && drawing) {
          const color = colorPicker.value;
          const width = lineWidth.value;
          const pos = getEventPos(e);

          ctx.strokeStyle = color;
          ctx.lineWidth = width;
          ctx.lineCap = "round";

          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(pos.x, pos.y);
          ctx.stroke();

          socket.emit("draw_line", {
            startX,
            startY,
            endX: pos.x,
            endY: pos.y,
            color,
            width,
          });
        }
        drawing = false;
      }

      canvas.addEventListener("mousedown", startDrawing);
      canvas.addEventListener("mousemove", continueDrawing);
      canvas.addEventListener("mouseup", stopDrawing);
      canvas.addEventListener("mouseout", stopDrawing);

      canvas.addEventListener("touchstart", startDrawing);
      canvas.addEventListener("touchmove", continueDrawing);
      canvas.addEventListener("touchend", stopDrawing);
      canvas.addEventListener("touchcancel", stopDrawing);

      clearBtn.addEventListener("click", () => {
        if (isDrawer) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          socket.emit("clear");
        }
      });

      function enableDrawingTools(enabled) {
        isDrawer = enabled;
        [
          colorPicker,
          pencilBtn,
          eraserBtn,
          lineBtn,
          lineWidth,
          clearBtn,
        ].forEach((element) => {
          element.disabled = !enabled;
          if (enabled) {
            element.classList.remove("opacity-50", "cursor-not-allowed");
          } else {
            element.classList.add("opacity-50", "cursor-not-allowed");
          }
        });

        canvas.style.cursor = enabled ? "crosshair" : "not-allowed";
      }

      function enableChat(enabled) {
        chatInput.disabled = !enabled;
        sendChatBtn.disabled = !enabled;
        if (enabled) {
          [chatInput, sendChatBtn].forEach((el) =>
            el.classList.remove("opacity-50", "cursor-not-allowed")
          );
        } else {
          [chatInput, sendChatBtn].forEach((el) =>
            el.classList.add("opacity-50", "cursor-not-allowed")
          );
        }
      }

      function addChatMessage(playerName, message, isCorrect = false) {
        const div = document.createElement("div");
        div.className = `p-2 rounded mb-1 ${
          isCorrect ? "bg-green-100 border-l-4 border-green-500" : "bg-gray-100"
        }`;
        div.innerHTML = `<strong>${playerName}:</strong> ${message} ${
          isCorrect ? "âœ…" : ""
        }`;
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      function showAlmostMessage(message) {
        almostMessage.textContent = message;
        almostMessage.classList.remove("hidden");

        setTimeout(() => {
          almostMessage.classList.add("hidden");
        }, 3000);
      }

      function updatePlayersList(players, currentDrawerId) {
        playersList.innerHTML = "";
        players.forEach((player) => {
          const div = document.createElement("div");
          const isCurrentDrawer = player.id === currentDrawerId;
          div.className = `flex justify-between items-center p-2 rounded ${
            isCurrentDrawer
              ? "bg-blue-100 border-l-4 border-blue-500"
              : "bg-gray-50"
          }`;
          div.innerHTML = `
          <span>${player.name} ${isCurrentDrawer ? "ğŸ¨" : ""}</span>
          <span class="font-bold text-blue-600">${player.score}pts</span>
        `;
          playersList.appendChild(div);
        });
      }

      function startTimer(duration) {
        let timeLeft = duration / 1000;

        if (gameTimer) clearInterval(gameTimer);

        gameTimer = setInterval(() => {
          const minutes = Math.floor(timeLeft / 60);
          const seconds = timeLeft % 60;
          timer.textContent = `â° ${minutes}:${seconds
            .toString()
            .padStart(2, "0")}`;

          if (timeLeft <= 0) {
            clearInterval(gameTimer);
            timer.textContent = "â° Temps Ã©coulÃ© !";
          }
          timeLeft--;
        }, 1000);
      }

      socket.on("initCanvas", (history) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        history.forEach((item) => {
          if (item.type === "draw") {
            const data = item.data;
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.width;
            ctx.lineCap = "round";

            if (data.start) {
              ctx.beginPath();
              ctx.moveTo(data.x, data.y);
            } else {
              ctx.lineTo(data.x, data.y);
              ctx.stroke();
            }
          } else if (item.type === "draw_line") {
            const d = item.data;
            ctx.strokeStyle = d.color;
            ctx.lineWidth = d.width;
            ctx.lineCap = "round";

            ctx.beginPath();
            ctx.moveTo(d.startX, d.startY);
            ctx.lineTo(d.endX, d.endY);
            ctx.stroke();
          }
        });
      });

      socket.on("playersUpdate", (data) => {
        updatePlayersList(data.players, data.currentDrawer);
      });

      socket.on("canStartGame", (data) => {
        if (data.canStart) {
          startGameBtn.classList.remove("hidden");
          gameStatus.textContent =
            "âœ… PrÃªt Ã  dÃ©marrer ! Cliquez sur le bouton pour commencer.";
        } else {
          startGameBtn.classList.add("hidden");
          gameStatus.textContent =
            "En attente de joueurs... (Il faut au moins 2 joueurs)";
        }
      });

      socket.on("gameStarted", (data) => {
        addChatMessage(
          "ğŸ® SystÃ¨me",
          `ğŸ‰ ${data.playerName} a dÃ©marrÃ© le jeu !`
        );
        startGameBtn.classList.add("hidden");
        startGameBtn.disabled = false;
        startGameBtn.textContent = "ğŸ® DÃ©marrer le jeu";
      });

      socket.on("newRound", (data) => {
        gameStatus.textContent = "ğŸ® Partie en cours";
        currentDrawer.textContent = `ğŸ¨ ${data.drawerName} dessine`;
        wordToGuess.textContent = "";

        nextRoundBtn.classList.add("hidden");
        nextRoundBtn.disabled = false;
        nextRoundBtn.textContent = "ğŸš€ Lancer la prochaine manche";
        almostMessage.classList.add("hidden");

        enableDrawingTools(data.drawerId === socket.id);
        enableChat(data.drawerId !== socket.id);

        startTimer(60000); 

        addChatMessage(
          "ğŸ® SystÃ¨me",
          `${data.drawerName} commence Ã  dessiner !`
        );
      });

      socket.on("wordToDrawr", (data) => {
        if (data.isDrawer) {
          wordToGuess.textContent = `ğŸ¯ Mot Ã  dessiner: ${data.word}`;
          addChatMessage("ğŸ® SystÃ¨me", `Votre mot Ã  dessiner: ${data.word}`);
        }
      });

      socket.on("gameStatus", (data) => {
        gameStatus.textContent = data.message;
        if (!data.active) {
          enableDrawingTools(false);
          enableChat(false);
          timer.textContent = "";
          if (gameTimer) clearInterval(gameTimer);
        }
      });

      socket.on("chatMessage", (data) => {
        addChatMessage(data.playerName, data.message, data.isCorrect);
      });

      socket.on("correctGuess", (data) => {
        addChatMessage(
          "ğŸ® SystÃ¨me",
          `ğŸ‰ ${data.playerName} a trouvÃ© le mot "${data.word}" ! (+10 points)`
        );
      });

      socket.on("almostCorrect", (data) => {
        showAlmostMessage(data.message);
      });

      socket.on("roundEnd", (data) => {
        if (gameTimer) clearInterval(gameTimer);

        let message = "";
        if (data.reason === "guessed") {
          message = `ğŸ‰ Mot trouvÃ© ! Le mot Ã©tait: ${data.word}`;
        } else if (data.reason === "timeout") {
          message = `â° Temps Ã©coulÃ© ! Le mot Ã©tait: ${data.word}`;
        } else if (data.reason === "disconnected") {
          message = `ğŸ‘¤ Le dessinateur s'est dÃ©connectÃ©. Le mot Ã©tait: ${data.word}`;
        }

        addChatMessage("ğŸ® SystÃ¨me", message);

        if (data.waitingForNext) {
          nextRoundBtn.classList.remove("hidden");
          addChatMessage(
            "ğŸ® SystÃ¨me",
            'ğŸ‘† Cliquez sur "Lancer la prochaine manche" pour continuer'
          );
          gameStatus.textContent = "â¸ï¸ En attente de la prochaine manche";
        } else {
          addChatMessage("ğŸ® SystÃ¨me", "â³ Nouvelle manche dans 3 secondes...");
        }

        enableDrawingTools(false);
        enableChat(false);
        timer.textContent = "";
      });

      socket.on("nextRoundStarted", (data) => {
        addChatMessage(
          "ğŸ® SystÃ¨me",
          `ğŸš€ ${data.playerName} a lancÃ© la prochaine manche !`
        );
        nextRoundBtn.classList.add("hidden");
      });

      socket.on("draw", (data) => {
        ctx.strokeStyle = data.color;
        ctx.lineWidth = data.width;
        ctx.lineCap = "round";

        if (data.start) {
          ctx.beginPath();
          ctx.moveTo(data.x, data.y);
        } else {
          ctx.lineTo(data.x, data.y);
          ctx.stroke();
        }
      });

      socket.on("draw_line", (data) => {
        ctx.strokeStyle = data.color;
        ctx.lineWidth = data.width;
        ctx.lineCap = "round";

        ctx.beginPath();
        ctx.moveTo(data.startX, data.startY);
        ctx.lineTo(data.endX, data.endY);
        ctx.stroke();
      });

      socket.on("clear", () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      });

      enableDrawingTools(false);
      enableChat(false);
      updateToolButtons();

      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      window.addEventListener("orientationchange", () => {
        setTimeout(resizeCanvas, 100);
      });
    </script>
  </body>
</html>
